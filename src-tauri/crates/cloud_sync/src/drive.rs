use std::sync::{Arc, Mutex, PoisonError};

// Generated by Claud
use serde::{Deserialize, Serialize};
use serde_json::json;

use crate::{exchange::CachedAccessToken, GoogleUserInfo};

#[derive(Debug)]
pub enum DriveError 
{
    FileNotFound(String),
    IoError(std::io::Error),
    HttpError(ureq::Error),
    JsonError(serde_json::Error),
    AccessError(String), // Error when trying to refresh the users session
    Poison(String),
}
 
impl From<std::io::Error> for DriveError 
{
    fn from(err: std::io::Error) -> Self 
    {
        DriveError::IoError(err)
    }
}

impl From<ureq::Error> for DriveError 
{
    fn from(err: ureq::Error) -> Self 
    {
        DriveError::HttpError(err)
    }
}

impl From<serde_json::Error> for DriveError 
{
    fn from(err: serde_json::Error) -> Self 
    {
        DriveError::JsonError(err)
    }
}

impl<T> From<PoisonError<T>> for DriveError
{
    fn from(value: PoisonError<T>) -> Self 
    {
        Self::Poison(value.to_string())
    }
}

impl std::fmt::Display for DriveError 
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result 
    {
        match self 
        {
            DriveError::FileNotFound(path) => write!(f, "File not found: {}", path),
            DriveError::IoError(err) => write!(f, "IO error: {}", err),
            DriveError::HttpError(err) => write!(f, "HTTP error: {}", err),
            DriveError::JsonError(err) => write!(f, "JSON error: {}", err),
            DriveError::AccessError(err) => write!(f, "Access error: {}", err),
            DriveError::Poison(err) => write!(f, "Poison error: {}", err),
        }
    }
}

impl std::error::Error for DriveError {}

#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct DriveFileInfo 
{
    pub id: String,
    pub kind: String,
    pub mime_type: String,
    pub name: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct DriveFileList
{
    pub files: Vec<DriveFileInfo>,
}

#[derive(Debug)]
pub struct DriveSyncApi 
{
    access_token: Mutex<CachedAccessToken>,
    meta_key: String,
    meta_value: String,
}

impl DriveSyncApi {
    pub fn new(access_token: CachedAccessToken, key: String, value: String) -> Self 
    {
        Self 
        { 
            access_token: Mutex::new(access_token),
            meta_key: key, 
            meta_value: value 
        }
    }

    pub fn read(&self) -> Result<Option<String>, DriveError>
    {
        match self.find_file()?
        {
            Some(file) => Ok(Some(self.get_file_text(&file.id)?)),
            None => Ok(None),
        }
    }

    pub fn write(&self, content: &str) -> Result<(), DriveError>
    {
        match self.find_file()?
        {
            Some(file) => {
                self.set_file_text(&file.id, content)?;
                Ok(())
            },
            None => {
                self.create_file(Some(content))?;
                Ok(())
            }
        }
    }

    pub fn get_user_info(&self) -> Result<GoogleUserInfo, String>
    {
        let access_token = {
            let mut binding = self.access_token.lock().unwrap();
            binding.get_access_token()?.to_string()
        };

        let response = ureq::get("https://openidconnect.googleapis.com/v1/userinfo")
            .set("Authorization", &format!("Bearer {}", access_token))
            .call();

        match response 
        {
            Ok(resp) => {
                let json = resp.into_string().map_err(|e| format!("Failed to read response: {e}"))?;
                serde_json::from_str(&json)
                    .map_err(|e| format!("Failed to parse user info JSON: {e}\nResponse: {json}"))
            }
            Err(ureq::Error::Status(_, resp)) => {
                let status = resp.status();
                let body = resp.into_string().unwrap_or_default();
                Err(format!("HTTP {}: {}", status, body))
            }
            Err(e) => Err(format!("Request error: {}", e)),
        }
    }

    fn file_name(&self) -> &str 
    {
        &self.meta_value
    }

    fn create_file(&self, content: Option<&str>) -> Result<DriveFileInfo, DriveError> 
    {
        let metadata = json!({
            "name": self.file_name(),
            "mimeType": "text/plain",
            "properties": {
                self.meta_key.clone(): self.meta_value
            }
        });

        let boundary = "BOUNDARY123456789";
        let multipart_body = format!(
            "--{boundary}\r\n\
            Content-Type: application/json; charset=UTF-8\r\n\r\n\
            {metadata}\r\n\
            --{boundary}\r\n\
            Content-Type: text/plain\r\n\r\n\
            {content}\r\n\
            --{boundary}--",
            boundary = boundary,
            metadata = metadata.to_string(),
            content = content.unwrap_or_default()
        );

        let response = ureq::post("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart")
            .set("Authorization", &format!("Bearer {}", self.get_access_token()?))
            .set("Content-Type", &format!("multipart/related; boundary={}", boundary))
            .send_string(&multipart_body)?;

        let response_text = response.into_string()?;
        let response = serde_json::from_str(&response_text)?;
        
        Ok(response)
    }

    fn get_file_text(&self, file_id: &str) -> Result<String, DriveError> 
    {
        let url = format!("https://www.googleapis.com/drive/v3/files/{}?alt=media", file_id);
        
        let response = ureq::get(&url)
            .set("Authorization", &format!("Bearer {}", self.get_access_token()?))
            .call()?;

        Ok(response.into_string()?)
    }

    fn set_file_text(&self, file_id: &str, new_content: &str) -> Result<DriveFileInfo, DriveError> 
    {
        let url = format!("https://www.googleapis.com/upload/drive/v3/files/{}?uploadType=media", file_id);
        
        let response = ureq::patch(&url)
            .set("Authorization", &format!("Bearer {}", self.get_access_token()?))
            .set("Content-Type", "text/plain")
            .send_string(new_content)?;

        let response_text = response.into_string()?;
        let response = serde_json::from_str(&response_text)?;
        
        Ok(response)
    }

    fn list_files(&self, query: Option<&str>) -> Result<DriveFileList, DriveError> 
    {
        let mut url = "https://www.googleapis.com/drive/v3/files".to_string();
        
        if let Some(q) = query 
        {
            url.push_str(&format!("?q={}", urlencoding::encode(q)));
        }

        let response = ureq::get(&url)
            .set("Authorization", &format!("Bearer {}", self.get_access_token()?))
            .call()?;

        let response_text = response.into_string()?;
        let json_response = serde_json::from_str(&response_text)?;
        
        Ok(json_response)
    }

    pub fn find_file(&self) -> Result<Option<DriveFileInfo>, DriveError>
    {
        let query = format!("name='{}' and properties has {{key='{}' and value='{}'}} and trashed=false", self.file_name(), self.meta_key, self.meta_value);
        
        let search_result = self.list_files(Some(&query))?;
        
        Ok(search_result.files.first().cloned())
    }

    fn get_access_token(&self) -> Result<String, DriveError>
    {
        let mut binding = self.access_token.lock()?;
        let token = binding.get_access_token().map_err(|e| DriveError::AccessError(e))?;
        Ok(token.to_string()) // Clone the token instead of returning a reference
    }
}